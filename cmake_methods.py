# This is simple clone of scons methods.py.
# Because methods.py imports some unnecessary for cmake scons modules, and we can't really change scons functions, 
# we can't just use methods.py directly, and so need to create this code duplicate of some functions,
# which we will invoke from cmake.

import os
import re
import glob
import subprocess
from collections import OrderedDict
from compat import iteritems, isbasestring, open_utf8, decode_utf8, qualname

def save_active_platforms(apnames, ap):

    for x in ap:
        svg_names = []
        if os.path.isfile(x + "/logo.svg"):
            svg_names.append("logo")
        if os.path.isfile(x + "/run_icon.svg"):
            svg_names.append("run_icon")

        for name in svg_names:
            svgf = open(x + "/" + name + ".svg", "rb")
            b = svgf.read(1)
            svg_str = " /* AUTOGENERATED FILE, DO NOT EDIT */ \n"
            svg_str += " static const char *_" + x[9:] + "_" + name + '_svg = "'
            while len(b) == 1:
                svg_str += "\\" + hex(ord(b))[1:]
                b = svgf.read(1)

            svg_str += '";\n'

            svgf.close()

            # NOTE: It is safe to generate this file here, since this is still executed serially
            wf = x + "/" + name + "_svg.gen.h"
            with open(wf, "w") as svgw:
                svgw.write(svg_str)

# composes OrderedDict from modules_ids and modules_paths arrays and calls write_modules
def cmake_write_modules(modules_ids, modules_paths):
    from collections import OrderedDict
    length = min(len(modules_ids), len(modules_paths))
    modules_list = OrderedDict()
    for i in range(length):
        name = modules_ids[i]
        path = modules_paths[i]
        modules_list[name] = path

    write_modules(modules_list)

def write_modules(modules):
    includes_cpp = ""
    initialize_cpp = ""
    uninitialize_cpp = ""

    for name, path in modules.items():
        try:
            with open(os.path.join(path, "register_types.h")):
                includes_cpp += '#include "' + path + '/register_types.h"\n'
                initialize_cpp += "#ifdef MODULE_" + name.upper() + "_ENABLED\n"
                initialize_cpp += "\tinitialize_" + name + "_module(p_level);\n"
                initialize_cpp += "#endif\n"
                uninitialize_cpp += "#ifdef MODULE_" + name.upper() + "_ENABLED\n"
                uninitialize_cpp += "\tuninitialize_" + name + "_module(p_level);\n"
                uninitialize_cpp += "#endif\n"
        except OSError:
            pass

    modules_cpp = """// register_module_types.gen.cpp
/* THIS FILE IS GENERATED DO NOT EDIT */
#include "register_module_types.h"

#include "modules/modules_enabled.gen.h"

%s

void initialize_modules(ModuleInitializationLevel p_level) {
%s
}

void uninitialize_modules(ModuleInitializationLevel p_level) {
%s
}
""" % (
        includes_cpp,
        initialize_cpp,
        uninitialize_cpp,
    )

    # NOTE: It is safe to generate this file here, since this is still executed serially
    with open("modules/register_module_types.gen.cpp", "w") as f:
        f.write(modules_cpp)

def write_disabled_classes(class_list):
    f = open("core/disabled_classes.gen.h", "w")
    f.write("/* THIS FILE IS GENERATED DO NOT EDIT */\n")
    f.write("#ifndef DISABLED_CLASSES_GEN_H\n")
    f.write("#define DISABLED_CLASSES_GEN_H\n\n")
    for c in class_list:
        cs = c.strip()
        if cs != "":
            f.write("#define ClassDB_Disable_" + cs + " 1\n")
    f.write("\n#endif\n")


def sort_module_list(module_list, module_dependencies):
    out = OrderedDict()
    deps = {k: v[0] + list(filter(lambda x: x in module_list, v[1])) for k, v in module_dependencies.items()}

    frontier = list(module_list.keys())
    explored = []
    while len(frontier):
        cur = frontier.pop()
        deps_list = deps[cur] if cur in deps else []
        if len(deps_list) and any([d not in explored for d in deps_list]):
            # Will explore later, after its dependencies
            frontier.insert(0, cur)
            continue
        explored.append(cur)

    first = True
    for k in explored:
        if first:
            first = False
        else:
            print(";", end='')

        print(str(k), end='')
        
def generate_version_header(module_version_string=""):
    version_info = get_version_info(module_version_string)

    # NOTE: It is safe to generate these files here, since this is still executed serially.

    f = open("core/version_generated.gen.h", "w")
    f.write(
        """/* THIS FILE IS GENERATED DO NOT EDIT */
#ifndef VERSION_GENERATED_GEN_H
#define VERSION_GENERATED_GEN_H
#define VERSION_SHORT_NAME "{short_name}"
#define VERSION_NAME "{name}"
#define VERSION_MAJOR {major}
#define VERSION_MINOR {minor}
#define VERSION_PATCH {patch}
#define VERSION_STATUS "{status}"
#define VERSION_BUILD "{build}"
#define VERSION_MODULE_CONFIG "{module_config}"
#define VERSION_YEAR {year}
#define VERSION_WEBSITE "{website}"
#define VERSION_DOCS_BRANCH "{docs_branch}"
#define VERSION_DOCS_URL "https://docs.godotengine.org/en/" VERSION_DOCS_BRANCH
#endif // VERSION_GENERATED_GEN_H
""".format(
            **version_info
        )
    )
    f.close()

    fhash = open("core/version_hash.gen.cpp", "w")
    fhash.write(
        """/* THIS FILE IS GENERATED DO NOT EDIT */
#include "core/version.h"
const char *const VERSION_HASH = "{git_hash}";
""".format(
            **version_info
        )
    )
    fhash.close()